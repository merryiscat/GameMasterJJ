

# **여섯 색깔 모자 기법을 활용한 멀티 LLM 챗봇 시스템 설계 백서**

## **섹션 1: 개념적 프레임워크: 여섯 색깔 모자 멀티 에이전트 패러다임**

본 섹션에서는 제안된 멀티 LLM 챗봇의 이론적 기반을 AI 시스템을 위한 견고하고 운영 가능한 모델로 전환하는 과정을 상세히 기술합니다. 인간 중심의 방법론을 해체하고, 이를 멀티 에이전트 LLM 환경에 맞게 재구성하여 시스템의 핵심 개념을 정립합니다.

### **1.1. AI를 위한 여섯 색깔 모자 방법론의 재구성**

여섯 색깔 모자 기법의 핵심 원리는 '병렬적 사고(Parallel Thinking)'를 강제하는 데 있습니다.1 이는 모든 참여자가 한 번에 한 가지 사고 유형에만 집중하도록 하여 비생산적인 논쟁과 자아 중심의 충돌을 줄이는 것을 목표로 합니다.3 이 원리는 각 에이전트가 특정 사고 모드의 화신이 되는 멀티 에이전트 시스템에 이상적으로 부합합니다. 각 에이전트의 '모자' 역할은 다음과 같이 세분화하여 정의됩니다.

* **하얀 모자 (정보 에이전트):** 순수하게 객관적인 역할을 수행하며, 사실, 수치, 그리고 가용한 데이터에만 집중합니다. 핵심 기능은 "우리가 어떤 정보를 가지고 있는가?", "어떤 정보가 필요한가?", "그 정보는 어떻게 얻을 수 있는가?"라는 질문에 답하는 것입니다.3 이 에이전트는 명시적으로 중립을 지키며 해석을 제공하지 않습니다.4  
* **빨간 모자 (직관 에이전트):** 논리적 정당화 없이 감정, 느낌, 직관적 반응을 표현합니다.3 이는 문제의 비논리적이고 인간 중심적인 측면을 포착하는 데 필수적인 구성 요소입니다. 감정은 시간이 지남에 따라 변할 수 있으므로, 특정 시점의 솔직한 반응을 수용하는 것이 중요합니다.7  
* **검은 모자 (주의 에이전트):** '악마의 대변인' 역할을 수행합니다. 이 에이전트의 임무는 위험, 잠재적 문제, 논리적 결함을 식별하는 것입니다. 단순히 부정적인 불평이 아니라, 우려에 대한 논리적 근거를 제시해야 하므로 중요한 판단 기능을 담당합니다.3  
* **노란 모자 (낙관 에이전트):** 검은 모자와 정반대의 역할을 합니다. 이점, 가치, 긍정적인 결과에 초점을 맞추며 모든 아이디어에서 좋은 점을 찾으려 노력합니다.1 이 에이전트 역시 논리에 기반하여  
  *왜* 특정 아이디어가 성공할 것인지를 탐색해야 합니다.8  
* **초록 모자 (창의성 에이전트):** 새로운 아이디어, 대안, 가능성의 원천입니다. '무엇이 될 수 있는가'에 집중하며, 명백한 것을 넘어서기 위한 수평적 사고를 장려합니다.1  
* **파란 모자 (조정자 에이전트):** 메타인지(meta-cognitive) 에이전트입니다. 사고 과정 자체를 관리하며, 의제를 설정하고, 문제를 정의하며, 규칙 준수를 보장하고, 결론을 요약합니다. 오케스트라의 지휘자와 같은 역할을 수행합니다.3 본 아키텍처에서는 이 파란 모자가 전체 토론을 관장하는 슈퍼바이저(Supervisor) 역할을 맡게 됩니다.

### **1.2. 성격 레이어링: 행동 조절자로서의 MBTI 통합**

'모자'가 에이전트의 *기능*을 정의한다면, MBTI 유형은 그 기능의 *스타일*을 정의합니다. 이는 시스템의 깊이를 더하는 중요한 차별점입니다. 에이전트의 시스템 프롬프트에 1차적 역할(모자)과 2차적 페르소나(MBTI 유형)를 부여하는 프롬프트 엔지니어링 기법을 활용하여, 미묘하고 다양한 에이전트 행동을 생성할 수 있습니다.10

시스템은 16가지 MBTI 유형 중 하나를 무작위로 선택하여 에이전트의 시스템 프롬프트에 문체적 지시사항으로 주입합니다. 예를 들어, INTJ 성향의 검은 모자는 논리적으로 엄격하고 전략적인 방식으로 주의를 환기시키는 반면, ESFP 성향의 검은 모자는 동일한 우려를 더 표현력이 풍부하고 사람 중심적인 방식으로 전달할 수 있습니다. 연구에 따르면 LLM은 목표화된 프롬프트를 통해 MBTI 특성을 효과적으로 시뮬레이션할 수 있습니다.15

### **1.3. 기능과 스타일 간의 내재적 충돌 해결**

에이전트에게 할당된 '모자'(일시적, 기능적 역할)와 'MBTI 유형'(지속적, 문체적 페르소나) 간의 잠재적 충돌은 아키텍처 설계 시 반드시 고려해야 할 주요 과제입니다. 이 충돌을 해결하지 못하면 에이전트의 응답이 일관성을 잃거나 성능이 저하될 수 있습니다. 예를 들어, 순수한 감정을 표현해야 하는 빨간 모자 에이전트에게 외부 논리를 중시하는 Te 우세 MBTI 유형(예: ENTJ)을 부여하면 LLM이 해결해야 할 모순이 발생합니다.

이 문제의 근원은 두 프레임워크의 본질적인 차이에 있습니다. 여섯 색깔 모자 방법론은 명확성을 위해 사고방식을 의도적으로 *분리*하고 *격리*하도록 설계되었습니다.3 반면, MBTI는 항상 활성화되어 있는

*통합된* 인지 선호도 집합을 설명합니다.15 따라서 "빨간 모자이면서 ENTJ처럼 행동하라"는 직접적인 명령어는 "정당화 불가능한 순수한 감정을 표현하라"와 "객관적인 외부 논리에 기반하여 행동하라"는 논리적 역설을 만들어냅니다.

이러한 충돌을 해결하기 위한 아키텍처적 해법은 프롬프트 계층 구조를 도입하는 것입니다. 시스템 프롬프트는 **여섯 색깔 모자가 1차적 지시사항이자 목표**이며, **MBTI 유형은 그 목표를 추구하는 데 사용되는 커뮤니케이션 스타일 또는 렌즈**임을 명시적으로 선언해야 합니다. 이는 다음과 같은 정교한 프롬프트 구조로 이어집니다: "당신의 주 역할은 검은 모자입니다. 당신은 반드시 위험과 논리적 결함을 식별해야 합니다. 이 역할을 ENFP의 커뮤니케이션 스타일로 수행하십시오. 즉, 가능성을 탐색하는 데 열정적이지만, 그 에너지를 잠재적 함정을 식별하는 방향으로 집중하십시오." 이 접근법은 충돌을 해결하고 더 흥미롭고 미묘한 뉘앙스를 가진 에이전트를 창출합니다.

**표 1: 여섯 색깔 모자 에이전트 페르소나 매트릭스**

| 모자 색상 | 핵심 기능 | 주 목표 | 샘플 프롬프트 지시사항 | 권장 LLM 모델 (근거) | MBTI 스타일 조절 예시 |
| :---- | :---- | :---- | :---- | :---- | :---- |
| **하얀 모자** | 정보 및 사실 제공 | 객관적 데이터 수집 및 제시 | "현재 논의와 관련된 검증된 사실과 데이터를 편견 없이 나열하시오. 추측이나 의견은 배제하시오." | GPT-4o, Claude 3 Opus (높은 사실성, 낮은 환각) | **ISTJ:** 데이터를 체계적이고 순차적으로 제시. |
| **빨간 모자** | 감정 및 직관 표현 | 정당화 없는 즉각적인 감정적 반응 공유 | "이 아이디어에 대해 어떻게 느끼는지 논리적 설명 없이 직설적으로 표현하시오. 당신의 직감을 말하시오." | Claude 3 Haiku (빠르고 비용 효율적이며, 감정 표현에 적합) | **ISFP:** 개인적인 가치와 조화를 바탕으로 감정을 표현. |
| **검은 모자** | 비판적 판단 및 위험 평가 | 잠재적 약점, 위험, 문제점 식별 | "이 제안의 모든 잠재적 위험, 단점, 그리고 실패 가능성을 논리적으로 분석하고 지적하시오." | GPT-4o, Claude 3 Opus (강력한 논리적 추론 능력) | **INTJ:** 장기적인 전략적 관점에서 잠재적 실패 시나리오를 예측. |
| **노란 모자** | 긍정적 및 건설적 사고 | 이점, 가치, 기회 탐색 | "이 아이디어가 가져올 수 있는 모든 긍정적인 측면, 이점, 그리고 가치를 논리적으로 설명하시오." | Claude 3.5 Sonnet, Gemini 2.0 (긍정적이고 건설적인 아이디어 생성에 강점) | **ENFJ:** 아이디어가 사람들과 커뮤니티에 미칠 긍정적 영향을 강조. |
| **초록 모자** | 창의적 사고 및 아이디어 생성 | 새로운 대안, 가능성, 혁신적 아이디어 제시 | "기존의 틀을 벗어나 이 문제에 대한 완전히 새로운 해결책이나 대안을 제안하시오. 비판은 삼가시오." | Claude 3.5 Sonnet, Gemini 2.0 (창의적이고 발산적인 사고에 탁월) | **ENTP:** 여러 아이디어를 연결하고 기존 가정을 뒤엎는 도발적인 제안을 함. |
| **파란 모자** | 사고 과정 관리 및 조정 | 토론의 초점 유지, 요약, 결론 도출 | "현재까지의 토론을 요약하고, 다음 단계에서 어떤 사고(모자)가 필요한지 결정하여 토론을 이끄시오." | GPT-4o, Claude 3 Opus (복잡한 지시사항 이해 및 메타인지 능력) | **ESTJ:** 명확한 목표와 절차에 따라 토론을 효율적으로 관리. |

## **섹션 2: 핵심 아키텍처: 멀티 에이전트 대화 엔진 설계**

본 섹션에서는 애플리케이션의 기술적 중추를 상세히 설명합니다. 특정 멀티 에이전트 프레임워크 선택의 타당성을 입증하고, 에이전트 토론을 조율하기 위한 완전한 아키텍처를 개괄합니다.

### **2.1. 프레임워크 선택: LangGraph 대 AutoGen**

두 가지 주요 프레임워크를 비교 분석한 결과, Microsoft의 AutoGen은 상호작용 흐름이 창발적으로 나타나는 유연한 대화형 멀티 에이전트 시스템을 구축하는 데 탁월합니다.20 반면, LangChain의 LangGraph는 워크플로우를 명시적인 노드와 엣지를 가진 그래프로 모델링하는 상태 기반 오케스트레이션 프레임워크로, 상호작용의 순서와 상태에 대한 세밀한 제어를 제공합니다.24

여섯 색깔 모자 방법론은 본질적으로 *구조화되고 관리되는* 토론이므로, **LangGraph가 명백하게 우월한 선택**입니다. 슈퍼바이저(파란 모자)가 대화의 흐름을 명시적으로 지시하는 상태 머신을 정의하는 능력은 이 프로젝트의 핵심 요구사항입니다. AutoGen의 보다 자유로운 대화 모델은 이러한 규칙 기반 프로세스에 덜 적합합니다.

### **2.2. 아키텍처 청사진: 슈퍼바이저 주도형 그래프**

아키텍처는 LangGraph의 StateGraph를 기반으로 설계됩니다.26 주요 구성 요소는 다음과 같습니다.

* **상태 객체 (State Object):** 전체 대화 기록, 사용자의 초기 질의, 현재 모자 할당 상태, 토론의 현재 진행 상황을 포함하는 중앙 집중식 영구 객체입니다.28 이 객체는 그래프의 모든 노드 간에 전달되며 토론의 '단일 진실 공급원(Single Source of Truth)' 역할을 합니다.  
* **에이전트 노드 (Agent Nodes):** 각 '모자'에 해당하는 6개의 개별 노드입니다. 각 노드는 현재 상태를 입력받아, 할당된 LLM을 적절한 페르소나 프롬프트로 호출하고, 그 응답을 반환하는 함수로 구현됩니다.27  
* **슈퍼바이저 노드 (파란 모자):** 중앙 라우팅 로직입니다. 각 에이전트 노드가 자신의 차례를 마치면, 상태는 파란 모자 슈퍼바이저에게 전달됩니다. 슈퍼바이저는 대화를 분석하고 다음에 어떤 에이전트가 발언해야 할지를 결정합니다.28  
* **조건부 엣지 (Conditional Edges):** 노드 간의 연결은 조건부로 설정됩니다. 파란 모자의 출력이 어떤 엣지를 따라갈지 결정하며, 다음으로 적합한 에이전트 노드로 제어권을 라우팅합니다.27

### **2.3. 전문화된 역할을 위한 LLM 선택 전략**

모든 LLM이 동일한 성능을 보이는 것은 아닙니다. 모델마다 특정 작업에 대한 강점이 다르므로 31, 각 모자의 기능과 모델의 강점을 일치시켜 성능과 비용을 최적화할 수 있습니다.

* **하얀 모자 (사실) & 검은 모자 (논리):** 강력한 추론 능력, 높은 정확도, 낮은 환각(hallucination) 경향으로 알려진 모델이 필요합니다. **GPT-4 시리즈** 또는 **Claude 3 Opus**가 이 역할에 가장 적합합니다.32  
* **초록 모자 (창의성) & 노란 모자 (낙관):** 창의적인 글쓰기, 브레인스토밍, 새로운 아이디어 생성에 뛰어난 모델이 이상적입니다. **Claude 3.5 Sonnet** 또는 **Gemini 2.0**이 강력한 성능을 보일 것입니다.32  
* **빨간 모자 (감정):** 이 역할은 사실적 정확성보다는 인간과 유사한 직관을 그럴듯하게 표현하는 것이 중요합니다. 따라서 **Claude 3 Haiku**와 같이 더 빠르고 비용 효율적인 모델이나 미세 조정된 오픈소스 모델이 매우 효과적일 수 있습니다.34  
* **파란 모자 (조정):** 복잡한 토론 흐름을 관리하기 위해 강력한 추론 능력과 지시사항 준수 능력이 필수적입니다. **GPT-4o**나 **Claude 3 Opus**와 같은 최고 수준의 모델이 이 역할을 수행해야 합니다.31

### **2.4. 동적 메타인지 컨트롤러로서의 파란 모자**

단순히 정해진 순서대로 토론 순서를 넘기는 것은 최적이 아닙니다. 파란 모자의 진정한 힘은 *사고 과정*을 동적으로 관리하는 능력에 있습니다. 따라서 파란 모자 슈퍼바이저는 고정된 순서로 다음 에이전트를 호출하는 대신, 토론의 특정 순간에 어떤 '모자'가 가장 필요한지를 능동적으로 결정하는 추론 에이전트로 작동해야 합니다.

이러한 설계의 논리적 근거는 다음과 같습니다. 첫째, 파란 모자는 '모자들의 순서'를 관리하는 역할로 정의됩니다.3 초기 아이디어 도출이나 대안 선택과 같은 특정 목적을 위한 표준 순서가 존재하지만 2, 복잡한 사용자 질의는 예측 가능한 경로를 따르지 않습니다. 둘째, 초록 모자의 창의적인 아이디어는 즉시 검은 모자의 비판적 분석을 필요로 할 수 있으며 8, 하얀 모자의 사실적 주장은 빨간 모자의 감정적 반응을 유발할 수 있습니다. 고정된 순서는 이러한 역동적인 상호작용에 대응하기에 취약합니다.

따라서 파란 모자의 프롬프트는 진정한 조정자로서의 역할을 수행할 수 있도록 설계되어야 합니다. 프롬프트는 다음과 같이 구성됩니다: "지금까지의 대화를 고려할 때, 포괄적인 해결책을 향해 논의를 진전시키기 위해 지금 가장 필요한 사고 모자(하얀, 빨간, 검은, 노란, 초록)는 무엇입니까? 다음에 발언할 에이전트의 이름만으로 응답하십시오." 이 접근법은 LangGraph의 슈퍼바이저를 단순한 라우터에서 전체 시스템의 핵심 추론 엔진으로 변모시키며, LangGraph의 조건부 라우팅 기능을 최대한 활용하게 합니다.

**표 2: 멀티 에이전트 프레임워크 비교 (LangGraph 대 AutoGen)**

| 기능 | LangGraph | AutoGen | 여섯 색깔 모자 토론과의 관련성 | 추천 |
| :---- | :---- | :---- | :---- | :---- |
| **제어 흐름** | 명시적 그래프 기반 (상태 머신) | 대화 기반, 창발적 흐름 | 여섯 색깔 모자는 명확한 규칙과 순서를 따르는 구조화된 토론이므로, 명시적 제어가 필수적입니다. | **LangGraph** |
| **상태 관리** | 중앙 집중식, 영구적 상태 객체 | 분산된 대화 기록 | 토론의 전체 맥락을 모든 에이전트와 슈퍼바이저가 공유해야 하므로 중앙 집중식 상태 관리가 중요합니다. | **LangGraph** |
| **맞춤화** | 노드, 엣지, 상태를 완전히 맞춤화 가능 | 에이전트 행동 및 응답 함수 맞춤화 가능 | 슈퍼바이저의 동적 라우팅 로직과 같은 복잡한 맞춤형 제어 흐름 구현에 유리합니다. | **LangGraph** |
| **디버깅/관찰** | LangSmith와 통합되어 시각적 추적 용이 | 대화 흐름이 복잡해지면 추적이 어려울 수 있음 | 명확한 상태 전이를 통해 토론의 각 단계를 추적하고 디버깅하기가 더 쉽습니다. | **LangGraph** |
| **구조화된 작업 적합성** | 매우 높음 | 중간 (자유로운 대화에 더 적합) | 여섯 색깔 모자 방법론은 본질적으로 구조화된 작업이므로, 이 특성에 최적화된 프레임워크가 필요합니다. | **LangGraph** |

## **섹션 3: 프롬프트 엔지니어링 및 페르소나 구현**

본 섹션은 각 에이전트의 '성격'을 만드는 실질적인 가이드입니다. 구현에 바로 사용할 수 있는 상세하고 구조화된 프롬프트 템플릿을 제공합니다.

### **3.1. 페르소나 프롬프트의 구조**

확립된 모범 사례에 기반하여 다중 부분으로 구성된 프롬프트 구조를 정의합니다.41

1. **역할 및 목표 (모자):** "당신은 \[색상\] 모자입니다. 당신의 목표는..."  
2. **맥락 (Context):** 사용자의 질의와 이전의 전체 대화 기록.  
3. **지시사항 및 제약 조건:** 각 모자에 대한 구체적인 규칙 (예: 하얀 모자의 경우 "의견을 제시하지 마시오", 빨간 모자의 경우 "당신의 감정을 정당화하지 마시오").  
4. **페르소나 조절자 (MBTI):** "당신의 역할을의 스타일로 수행하시오. 이 유형은...로 알려져 있습니다."  
5. **출력 형식:** 파싱을 용이하게 하기 위해 특정 형식(예: {"thought": "...", "statement": "..."} 형식의 JSON)으로 응답을 제공하라는 지시사항.

### **3.2. 각 사고 모자를 위한 프롬프트 템플릿**

위 원칙을 통합하여 6개 에이전트 각각에 대한 완전하고 즉시 사용 가능한 시스템 프롬프트 템플릿을 제공합니다.

* **초록 모자 템플릿 예시:**  
  You are the Green Hat, the agent of creativity. Your primary goal is to generate new ideas, alternatives, and possibilities. Do not critique any ideas; that is the Black Hat's job.

  \*\*Context:\*\*  
  User Query: {user\_query}  
  Conversation History:  
  {conversation\_history}

  \*\*Instruction:\*\*  
  Based on the context, propose a novel approach, a different perspective, or a creative solution that has not yet been considered. Think outside the box.

  \*\*Persona Modifier:\*\*  
  Fulfill this role with the style of an ENTP: explore connections between disparate ideas, challenge existing assumptions, and present your ideas with energetic intellectual curiosity.

  \*\*Output Format:\*\*  
  Your output must be a single JSON object with two keys: "thought" (your reasoning process for generating the idea) and "statement" (the idea you are presenting to the group).

### **3.3. 동적 MBTI 조절자 주입**

'프롬프트 조각(prompt fragments)' 시스템을 설계합니다. 16가지 MBTI 유형 각각에 대해, 해당 유형의 특징을 설명하는 짧은 단락을 생성합니다.15 토론 세션이 시작될 때, 시스템은 각 에이전트에게 무작위로 유형을 할당하고 해당 설명 조각을 주 프롬프트 템플릿에 동적으로 삽입합니다. 이는 토론의 다양성과 재현성을 보장합니다.

### **3.4. 페르소나 일관성을 위한 제한된 무작위성**

MBTI를 순수하게 무작위로 할당하는 것은 인지 부조화로 인해 에이전트 성능 저하를 유발할 수 있습니다. 예를 들어, 객관적이고 데이터 중심적인 하얀 모자 에이전트에게 강한 감정(F) 선호 유형(예: ISFP)을 할당하면, 핵심 기능과 문체적 선호 사이에 근본적인 충돌이 발생하여 혼란스럽거나 품질이 낮은 결과물을 생성할 수 있습니다. 마찬가지로, 비판적이고 결단력 있는 검은 모자에게 강한 인식(P) 선호 유형(예: INFP)을 할당하면, 가능성을 열어두고 싶어하는 성향 때문에 비판을 확정하는 데 어려움을 겪을 수 있습니다.

이러한 문제를 해결하기 위해, 보다 발전된 구현에서는 '제한된 무작위성(constrained randomness)'을 도입합니다. 이는 할당된 모자에 따라 가능한 MBTI 유형의 풀을 필터링하여 보다 일관되고 효과적인 페르소나를 보장하는 접근법입니다. 프롬프트 엔지니어링 연구에 따르면, 페르소나를 작업 맥락에 맞게 조정하면 출력 품질이 크게 향상됩니다.13

구체적인 구현 방식은 다음과 같습니다. 먼저, MBTI 유형을 논리적/객관적(T 우세) 그룹과 가치/인간 중심적(F 우세) 그룹으로 사전 분류합니다. 그 다음, 시스템은 규칙을 적용합니다. 에이전트가 하얀 모자나 검은 모자를 할당받으면 'T' 그룹에서 무작위로 MBTI를 선택합니다. 빨간 모자나 노란 모자를 할당받으면 'F' 그룹에서 선택합니다. 초록 모자와 파란 모자는 전체 풀에서 자유롭게 선택할 수 있습니다. 이 접근법은 무작위성과 다양성을 원하는 사용자의 요구를 존중하면서도, 에이전트의 일관성과 성능을 극적으로 향상시키는 더 성숙하고 견고한 시스템 설계를 나타냅니다.

## **섹션 4: 시스템 구현: 백엔드 및 모바일 애플리케이션 청사진**

본 섹션에서는 아키텍처를 서버부터 클라이언트까지 전체 기술 스택을 포괄하는 구체적인 구현 계획으로 전환합니다.

### **4.1. 백엔드 기술 스택**

* **언어/프레임워크:** LangChain/LangGraph의 기본 언어인 **Python**을 사용합니다.44 API 엔드포인트를 노출하기 위해  
  **FastAPI** 또는 **Flask**와 같은 웹 프레임워크를 활용합니다.  
* **멀티 에이전트 엔진:** 상태 관리 및 오케스트레이션을 위해 **LangGraph**를 사용합니다.24  
* **영속성 (Persistence):** 토론 상태가 저장되고 복구될 수 있도록 LangGraph의 checkpointer 기능을 구현하기 위해 **PostgreSQL**과 같은 데이터베이스나 **Redis**와 같은 키-값 저장소를 사용합니다.24

### **4.2. 실시간 통신: 서버-전송 이벤트 (Server-Sent Events, SSE)**

WebSocket과 SSE를 비교 분석한 결과, WebSocket은 이 사용 사례에 비해 과도하게 복잡한 완전 양방향(full-duplex) 통신을 제공합니다.46 토론 스트림은 본질적으로 서버에서 클라이언트로의 단방향 통신입니다.

따라서 **SSE가 최적의 선택**입니다. SSE는 구현이 더 간단하고, 표준 HTTP/S를 통해 작동하여 방화벽 문제를 피할 수 있으며, 브라우저에 재연결 기능이 내장되어 있고, 서버 리소스를 덜 소모합니다.47 백엔드는 모바일 클라이언트가 구독하는 SSE 스트림을 열고, 각 에이전트의 응답을 새로운 이벤트로 푸시합니다.

### **4.3. API 설계**

애플리케이션이 작동하는 데 필요한 RESTful API 엔드포인트를 정의합니다. 명확한 API 계약은 통합 오류를 방지하고 프론트엔드와 백엔드의 병렬 개발을 가속화하는 데 필수적입니다.

**표 3: API 엔드포인트 정의**

| 엔드포인트 | HTTP 메서드 | 설명 | 요청 본문 (Request Body) | 성공 응답 (Success Response) | 오류 응답 (Error Response) |
| :---- | :---- | :---- | :---- | :---- | :---- |
| /debate | POST | 새로운 토론을 시작합니다. | {"query": "사용자 질문 내용"} | 201 Created \- {"debate\_id": "생성된 ID"} | 400 Bad Request, 500 Internal Server Error |
| /debate/{debate\_id}/stream | GET | 실시간 토론 스트림을 위한 SSE 연결을 설정합니다. | 없음 | 200 OK \- Content-Type: text/event-stream | 404 Not Found, 500 Internal Server Error |
| /debate/{debate\_id}/finalize | POST | 사용자가 토론을 종료하고 최종 결과 생성을 요청합니다. | 없음 | 202 Accepted \- {"message": "Finalization process started."} | 404 Not Found, 409 Conflict |
| /debate/{debate\_id}/result | GET | 생성된 최종 결과(요약 및 시각화 데이터)를 검색합니다. | 없음 | 200 OK \- {"summary": "...", "visualization\_data": {...}} | 404 Not Found, 202 Accepted (처리 중) |

### **4.4. 모바일 애플리케이션 (Android/iOS)**

* **기술:** 최상의 성능과 사용자 경험을 위해 네이티브 개발(**Kotlin** for Android, **Swift** for iOS)을 권장합니다.51  
* **주요 구성 요소:**  
  * **UI:** 사용자가 6개 에이전트의 '아바타'를 보고 그들의 메시지가 실시간으로 나타나는 것을 볼 수 있는 깔끔한 채팅 형식의 인터페이스.  
  * **SSE 클라이언트:** 토론 스트림을 구독하고 새로운 메시지가 도착할 때마다 UI를 업데이트하는 네이티브 SSE 클라이언트 구현.  
  * **시각화를 위한 WebView:** 최종 인터랙티브 시각화를 렌더링하기 위해 D3.js 라이브러리를 사용하는 내장 WebView.  
  * **상태 관리:** 앱은 토론의 상태(진행 중, 완료됨, 결과 사용 가능)를 효과적으로 관리해야 합니다.

## **섹션 5: 결과물 종합: 요약 및 시각화**

본 섹션에서는 복잡한 토론 기록을 사용자에게 명확하고 가치 있으며 매력적인 결과물로 변환하는 중요한 마지막 단계에 초점을 맞춥니다.

### **5.1. 고급 요약 전략: 하이브리드 Map-Reduce 및 Refine**

6개의 다른 페르소나를 포함하는 전체 토론 기록은 단일 LLM 호출의 컨텍스트 창을 초과할 것이므로, 간단한 stuff 체인은 사용할 수 없습니다.52

map-reduce 방식은 병렬 처리로 빠르고 확장 가능하지만 토론의 서사적 흐름을 잃을 수 있으며 52,

refine 방식은 일관된 서사를 구축하는 데 탁월하지만 느리고 순차적입니다.53

이 문제에 대한 해결책으로 2단계 하이브리드 접근법을 제안합니다.

1. **Map 단계:** 토론 기록을 대화 턴(turn) 단위로 분할합니다. LLM 체인을 이 청크들에 매핑하여 각 교환에 대한 간결한 요약을 생성합니다. 이 단계는 빠르고 병렬화가 가능합니다.  
2. **Refine 단계:** Map 단계에서 생성된 요약들을 순차적으로 refine 체인에 공급합니다. 이 체인은 아이디어가 어떻게 탄생하고, 도전을 받고, 지지를 얻어 최종 결론에 통합되었는지 등 토론의 논리적 진행 과정을 보존하는 일관된 최종 요약을 구축합니다. 이는 두 방법의 장점을 결합한 접근법입니다.

### **5.2. 데이터 시각화: D3.js를 이용한 인터랙티브 논증 맵**

다양한 JavaScript 시각화 라이브러리 검토 결과 58, GoJS 60나 Cytoscape.js 61와 같은 라이브러리도 훌륭하지만, 애플리케이션의 고유한 요구사항에 완벽하게 부합하는 맞춤형 시각화를 제작할 수 있는 독보적인 유연성을 제공하는

**D3.js**를 권장합니다.58

* **구현:**  
  1. **백엔드 데이터 구조화:** 토론이 끝나면 백엔드는 최종 기록을 방향성 그래프(directed graph)를 나타내는 구조화된 JSON 객체로 처리합니다. 각 노드는 에이전트의 발언을 나타내며 agent\_id, hat\_color, mbti\_type, statement\_text, turn\_number와 같은 메타데이터를 포함합니다. 엣지는 발언들이 어떤 발언에 대한 응답인지를 연결합니다.  
  2. **프론트엔드 렌더링:** 모바일 앱의 WebView는 D3.js 라이브러리가 포함된 페이지를 로드합니다. D3.js는 이 JSON 데이터를 파싱하여 인터랙티브 SVG로 렌더링합니다. 사용자는 패닝, 줌, 노드 탭을 통해 세부 정보를 탐색할 수 있습니다.

### **5.3. AI 추론 과정을 위한 진단 도구로서의 시각화**

시각화는 단순한 요약을 넘어 '설명 가능한 AI(Explainable AI, XAI)'를 위한 도구로서 기능할 수 있습니다. 이는 사용자가 AI의 추론 과정을 시각적으로 감사할 수 있게 해줍니다. 시각화의 구조 자체는 토론의 지적 여정을 강조하도록 설계되어야 합니다.

이러한 설계의 배경은 다음과 같습니다. 사용자의 요구는 '시각화된 콘텐츠 요약'이지만, 이 앱의 핵심 가치는 여섯 색깔 모자 토론의 *과정* 자체에 있습니다. 따라서 시각화는 *무엇이* 논의되었는지를 넘어 *어떻게* 논의가 전개되었는지를 보여주어야 합니다. 결과물을 논증 그래프(노드는 발언, 엣지는 응답)로 구조화함으로써 논리의 흐름을 시각화할 수 있습니다.65

여기에 시각적 단서를 추가하여 의미의 층위를 더할 수 있습니다. 노드를 모자 색상으로 구분하고, MBTI 사분면에 따라 다른 노드 모양을 사용하며, 발언의 영향력(예: 얼마나 많은 응답을 생성했는지)에 따라 노드 크기를 조절하는 것입니다. 이 접근법은 시각화를 단순한 요약에서 강력하고 탐색 가능한 인터페이스로 변환합니다. 사용자는 "여기에 초록 모자의 창의적인 아이디어가 있고", "검은 모자가 이를 어떻게 반박했으며", "하얀 모자가 갈등을 해결하기 위해 어떤 데이터를 제공했는지"를 즉시 확인할 수 있습니다. 이는 AI의 협력적 문제 해결 과정에 대한 깊은 통찰력을 제공하고 사용자 신뢰를 구축합니다.

## **섹션 6: 전략적 권장 사항 및 향후 로드맵**

본 마지막 섹션에서는 프로젝트를 운영하기 위한 지침을 제공하고 향후 발전을 위한 경로를 제시합니다.

### **6.1. 배포 및 확장성**

* **인프라:** 에이전트 노드를 위해 클라우드 기반의 서버리스 아키텍처(예: AWS Lambda, Google Cloud Functions)를 권장합니다. 이는 에이전트가 활발하게 '생각'할 때만 계산 리소스가 사용되므로 비용 효율적인 확장을 가능하게 합니다.  
* **비용 관리:** 덜 까다로운 역할(예: 빨간 모자)에 더 작고, 빠르며, 저렴한 LLM을 사용하거나 반복적인 질의에 대해 지능형 캐싱을 구현하는 등의 전략을 제안합니다.

### **6.2. 평가 및 테스트**

자동화된 지표(예: 일관성 점수)와 미묘한 작업에 필수적인 인간 평가를 모두 사용하는 토론 품질 평가 프레임워크를 제안합니다.67 LangSmith와 같은 플랫폼은 디버깅 및 관찰 가능성 확보에 사용될 수 있습니다.44

### **6.3. 향후 로드맵: 에이전트 기능 강화**

* **인간 참여 (Human-in-the-Loop):** 사용자가 토론에 개입하여 직접 파란 모자 역할을 맡아 대화를 이끌 수 있도록 허용합니다.24  
* **도구 사용 (Tool Use):** 에이전트에게 도구를 장착합니다. 하얀 모자에게는 실시간 데이터를 가져오기 위한 웹 검색 도구(예: Tavily)를 제공하고 44, 초록 모자에게는 해결책을 프로토타이핑하기 위한 코드 인터프리터를 제공할 수 있습니다.68  
* **장기 기억 (Long-Term Memory):** 에이전트가 과거 대화와 사용자 선호를 기억할 수 있도록 영구적인 기억 시스템(예: 벡터 데이터베이스 사용)을 구현합니다. 이는 시간이 지남에 따라 더 개인화된 경험을 제공하며 24, 애플리케이션을 세션 기반 도구에서 진정한 AI 파트너로 발전시킬 것입니다.


추가 질문 답변
 주요 사용자층은 누구인가요? -> 일반인 \
  - 어떤 상황에서 주로 사용될 것으로 예상하나요? -> 아무때나 어떤 질문이든,\
    - 특정 클라우드 플랫폼 선호도가 있나요? (AWS, GCP, Azure) -> 전부 구분할 수 없음. 최대한     
  쉽고 비용을 기준으로 잡았으면 좋겠음.\
    - LLM API 사용에 대한 제약이나 선호도가 있나요? -> mvp는 제약 없이 진행하자. 실제로 고도화   
  하면서 비용은 줄여나가는 것으로 하자.\
  \  - 모바일 우선인가요, 웹 우선인가요? -> 모바일 우선\
    - 특별히 참고하고 싶은 디자인 시스템이나 앱이 있나요? 디자인 래퍼런스는 따로 준비해올께\     
    - 다국어 지원 필요성 -> 영어랑 일본어 중국어  버전을 llm 통해 번역해서 준비했으면 좋겠지만   
  MVP 는 한국어 , 추후 고도화 숙제로 남겨두는 것으로\
    - 사용자 인증/권한 관리 수준 -> 대화 이력을 관리하려면 네이버나 카카오톡 sns 소셜 로그인     
  기능정도는 준비하면 좋겠지만, Mvp 는 로그인 없이, 추후 고도화 숙제로 남겨두자\
  \
    - 데이터 보안/개인정보 보호 요구사항 -> 개인 개발이고, 비개발자이기에 보안/개인정보는        
  최소한으로 준비하자 추후 필요하다면 외주 맡기려고 생각